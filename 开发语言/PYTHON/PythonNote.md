## 疑问
### 00001 正向前视断言、负向前视断言、正向后视断言、负向后视断言

|表示法|说明|实例|
|--|--|--|
|(?=...)|匹配条件是如果...出现在之后的位置，而不包含...|(?=.com)|
|(?!...)|匹配条件是如果...不出现在之后的位置，而不包含...|(?!.net)|
|(?<=...)|匹配条件是如果...出现在之前的位置，而不包含...|(?<=800-)|
|(?<!...)|匹配条件是如果...不出现在之前的位置，而不包含...|(?<!192\.168\.)|

注释：*不是很理解*


## 性能
### 00001 编译正则表达式 or Not

使用预编译的代码对象比直接使用字符串要快，因为解释器在执行字符串形式的代码前都必须把字符串编译成代码对象。
可以使用re.complie()提供的功能生成正则表达式对象

- 表达式对象： re.complie()生成的对象
- 匹配对象：使用match()和search()返回的对象


## 数据结构

### 00001 多线程编程一般结构
- UserRequestThread, 用以接收用户请求
- RequestProcessor, 用以处理用户请求，提供输出
- ReplyThread, 用以响应输出结果，返回用户或持久化

这一过程中的一个重要存在就是queue，理解队列的作用


## 思想
### 00001 多线程

线程共享相同的上下文，线程包括开始、执行顺序和结束三部分。

并行和数据共享是线程的特点和优势，是多任务间写作的关键。

**问题**
- 共享数据存在一定的风险，如果多个线程访问同一片数据，由于访问顺序的不同，可能导致结果的差异（*静态条件*， race condition）；
- 线程无法给予公平的执行时间，部分函数执行过程中处于阻塞状态，如不特殊处理将导致CPU时间分配向这些函数倾斜。


***全局解释器锁***
python代码由python虚拟机（解释器主循环）进行控制。在主循环中只能由一个控制线程在执行，即任意给定时刻仅有一个线程会被解释器执行。

GIL就是为了保证这一机制设计的。

**python虚拟机工作流程：**

1. 设置GIL
2. 切换进一个线程去运行
3. 执行如下流程：
    a. 制定数量的字节码指令 
    b. 线程主动让出控制权
4. 把线程设置回睡眠状态
5. 解锁GIL
6. 重复以上步骤


==*I/O密集型的Python程序要比计算密集型的代码能更好地例用多线程，因为在进行系统调用之前python会提前释放GIL，而非I/O操作，更倾向于线程始终占有处理器*==

**模块选择**
建议使用threading，因为thread主线程推出后，其他子线程将不做清理，直接退出；而threading会优雅的退出。
